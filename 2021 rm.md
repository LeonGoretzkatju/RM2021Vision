## 2021 rm

0. opencv 版本4.5.1, ubuntu18.04
1. for文件清楚，易读，解耦合，提高代码扩展性，代码复用度

2. 如何体现这一思想？

    1. 信息发送接受物理层应用层分离，便于提高协议扩展度
    2. 外部中断在主函数下切换不同配置，切换图像分辨率
    3. 自动识别在armor函数下，采用状态机，根据当前状态切换模式

3. 需求分析

    由于信息同步的问题，多线程优化的时间<🔓等待的时间，整体采用单线程，串口读取数据多线程，接受信息赋值给全局变量，实时更新，图像更新时用到读取，姿态融合。

     1. 接受下位机信息
         	1. 单开线程接受信息
            2. 当前角度，射速，位置等
     2. 识别图像信息
         	1. 灯条匹配， 数字识别
              	2. 装甲版类{矩形，中心位置，...}
              	3. 识别目标装甲版，返回装甲版优先队列
             * 图像中心位置权重高
             * 上一次识别目标权重高
             * 距离近的权重高
     3. 综合串口姿态和图像信息
         	1. 姿态融合
     4. 综合打击决策
         	1. 重力补偿
              	2. 预测 
     5. 发送信息给串口
         	1. 调试信息散度

4. 文件结构
   .
   ├── 2021 rm.md
   ├── Armor
   │   ├── Include
   │   └── Src
   ├── build
   ├── camera_mv.Config
   ├── CMakeLists.txt
   ├── Main.cpp
   ├── Other
   │   ├── Camera
   │   └── Serial
   ├── Predictor
   │   ├── Include
   │   └── Src
   └── Tools
       ├── Include
       ├── para
       └── Src

5. 实现步骤

    1. 思考过程
    * 首先思考我们这个程序需要什么样的功能，这个由需求端决定，然后我们思考完成这些功能可以提供的输入有那些，我们提供什么样的输出。
    * 对于我们的程序，自然是有视觉图像的处理，从相机处理出图像。那么这个图像是我们程序输入的一部分。
    * 接下来我们思考，是否只有这样一个图像信息可以足够我们作出判断，理论上这样的视频流是足够有这样信息，但是对于一些诸如当前移动速度，枪管发射出子弹的射速，云台摆动的速度，从视频流中提取出的信息是没有办法使用的。
    * 这样我们引入从下位机传递参数，这样一个信息，和图像信息作出综合判断。
    * 处理过后的数据，我们返回什么样子的数据给单片机驱动电机作出相应的动作？

    * 经过这样的一个大体的思考，我们就可以明确我们的输入，输出，编写什么样的类，应用什么关系（继承，组合，委托）来实现这样的输入输出。
    * 然后我们将底层的细节抽象掉，我们的输入就变成了视频流信息（图片），和读取图片进来的当前串口参数。
    * 接下来思考我们有了这样的输入，如何处理这样的图片，如何运用实时的串口信息，运用什么数据结构和算法，可以实现我们的目标。
    * 识别以及封装简单看下代码，下面阐述一下预测的思路：
    我们从搜寻状态获得了上一帧的图像信息，然后可以将那时候的串口信息封装到图像类中，那么我们得到一个完整的上一时刻的信息。
    从追踪状态中在roi区域中查找当前帧的信息（和搜寻一样），那么我们可以得到一个队列，存放装甲版的状态信息。
    根据这一队列，短时间内可以预测出装甲版下几个时刻的姿态信息，从而指导预判。

    1. 串口类编写
        1. 数据：不采用之前的协议，直接使用一个结构体将所有的信息传输，定长结构体
        2. receive_data根据buffer时事更新数据，根据图像变动需要读取结构体，可能需要加读锁。
    2. 相机驱动编写
    3. 装甲版识别调试
        1. main函数大致流程
        2. 状态机
        3. 装甲识别函数
        4. 读取视频，测试识别的准确度
    4. 输出偏移信息调试
        1. 编写追踪状态，预测函数，和相关类。
        2. 读取视频，测试输出连续程度

6. 命名规范（后续规范）
    1. 文件夹，文件，类名采用首字母大写的驼峰命名法
    2. 采用首字母小写的驼峰命名法
    3. 函数，实例，变量采用下划线命名法
7. TODO LIST
  1. 加入Bundle Adjustment以及sliding windows optimization，通过因子图的方式从根本上提高预测的准确性，kalman利用的是系统的马尔科夫性，但是实际中系统状态方程往往和之前历史状态数据有关
  2. 加入QT设计更加优雅的波形图 现在的波形图是临时用了OpenCV自带的凑数 体验感不好
  3. 在通信协议端尝试加入CRC校验
  4. 识别部分将学弟的目标检测识别部分加入 完成深度学习AI自瞄 这部分ARUW的Python自瞄思路非常好
  5. 考虑不同距离采用不同的kalman 参数
  6. 预测还是稍微有一些滞后 如何提升对于换向的准确性
